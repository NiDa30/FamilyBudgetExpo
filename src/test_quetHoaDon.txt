import React, { useState, useRef, useEffect } from "react";
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Alert,
  Image,
  ActivityIndicator,
} from "react-native";
import Icon from "react-native-vector-icons/MaterialCommunityIcons";
import { useNavigation } from "@react-navigation/native";
import { NativeStackNavigationProp } from "@react-navigation/native-stack";
import { RootStackParamList } from "../App";
import {
  CameraView,
  useCameraPermissions,
  PermissionStatus,
} from "expo-camera";
import * as ImagePicker from "expo-image-picker";
import { authInstance as auth } from "../firebaseConfig";
import * as ImageManipulator from "expo-image-manipulator";
import NetInfo from "@react-native-community/netinfo";

// ‚úÖ IMPORT SQLite & Sync Service
import { databaseService } from "./database/databaseService";
import { syncService } from "./service/sync/SyncEngine";

type QuethoadonNavigationProp = NativeStackNavigationProp<
  RootStackParamList,
  "Quethoadon"
>;

interface ExpenseItem {
  name: string;
  quantity: number;
  amount: number;
}

interface ExpenseData {
  store: string;
  address: string;
  phone: string;
  date: string;
  time: string;
  total: number;
  tax: number;
  discount: number;
  items: ExpenseItem[];
  method: string;
  createdAt: string;
  rawText?: string;
}

const Quethoadon = () => {
  const navigation = useNavigation<QuethoadonNavigationProp>();
  const [permission, requestPermission] = useCameraPermissions();

  const [photo, setPhoto] = useState<string | null>(null);
  const [expensesData, setExpensesData] = useState<ExpenseData | null>(null);
  const [editMode, setEditMode] = useState(false);
  const [loading, setLoading] = useState(false);
  const [step, setStep] = useState<"camera" | "result">("camera");
  const cameraRef = useRef<CameraView>(null);

  // ‚úÖ SYNC STATUS STATE
  const [isOnline, setIsOnline] = useState(true);
  const [unsyncedCount, setUnsyncedCount] = useState(0);

  // ‚úÖ INITIALIZE DATABASE & SYNC SERVICE
  useEffect(() => {
    const initializeServices = async () => {
      try {
        // Init database
        await database.init();

        // Start auto-sync service
        syncService.startAutoSync(30000); // Sync m·ªói 30 gi√¢y

        // Check sync status
        updateSyncStatus();

        // Listen to network changes
        const unsubscribe = NetInfo.addEventListener((state) => {
          setIsOnline(state.isConnected || false);
          if (state.isConnected) {
            // Khi c√≥ m·∫°ng tr·ªü l·∫°i, sync ngay
            console.log("üåê Network restored, triggering sync...");
            syncService.syncToFirebase();
          }
        });

        return () => {
          unsubscribe();
          syncService.stopAutoSync();
        };
      } catch (error) {
        console.error("‚ùå Error initializing services:", error);
      }
    };

    initializeServices();
  }, []);

  // ‚úÖ UPDATE SYNC STATUS
  const updateSyncStatus = async () => {
    const status = await syncService.getSyncStatus();
    setUnsyncedCount(status.unsyncedCount);
  };

  // ‚úÖ PERMISSION CHECK
  if (permission === null) {
    return (
      <View style={styles.centerContainer}>
        <ActivityIndicator size="large" color="#2196F3" />
        <Text style={styles.loadingText}>Chu·∫©n b·ªã camera...</Text>
      </View>
    );
  }

  if (!permission || permission.status !== PermissionStatus.GRANTED) {
    return (
      <View style={styles.centerContainer}>
        <Icon name="camera-off" size={80} color="#f44336" />
        <Text style={styles.errorTitle}>C·∫ßn quy·ªÅn Camera</Text>
        <Text style={styles.errorText}>
          ƒê·ªÉ qu√©t h√≥a ƒë∆°n, h√£y c·∫•p quy·ªÅn truy c·∫≠p camera
        </Text>
        <TouchableOpacity
          style={styles.grantButton}
          onPress={requestPermission}
        >
          <Text style={styles.grantButtonText}>C·∫§P QUY·ªÄN CAMERA</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => navigation.goBack()}
        >
          <Text style={styles.backButtonText}>Quay l·∫°i</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // ‚úÖ OCR FUNCTION
  const performOCR = async (imageUri: string): Promise<string> => {
    try {
      console.log("ƒêang x·ª≠ l√Ω OCR cho:", imageUri);

      const response = await fetch(imageUri);
      const blob = await response.blob();

      const base64 = await new Promise<string>((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result as string);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });

      const OCR_API_KEY = "K85684861288957";

      const formData = new FormData();
      formData.append("base64Image", base64);
      formData.append("isOverlayRequired", "false");
      formData.append("detectOrientation", "true");
      formData.append("scale", "true");
      formData.append("OCREngine", "2");

      const ocrResponse = await fetch("https://api.ocr.space/parse/image", {
        method: "POST",
        headers: { apikey: OCR_API_KEY },
        body: formData,
      });

      if (!ocrResponse.ok) {
        const errorText = await ocrResponse.text();
        console.error("OCR.space Error:", errorText);
        throw new Error(`OCR API error: ${ocrResponse.status}`);
      }

      const ocrData = await ocrResponse.json();

      if (ocrData.IsErroredOnProcessing) {
        console.error("OCR Processing Error:", ocrData.ErrorMessage);
        return "";
      }

      const detectedText = ocrData.ParsedResults?.[0]?.ParsedText || "";
      console.log("OCR Text:", detectedText);
      return detectedText;
    } catch (error: any) {
      console.error("OCR Error:", error);
      return "";
    }
  };

  // ‚úÖ CLEAN RECEIPT TEXT
  const cleanReceipt = (rawText: string): string => {
    const lines = rawText.split("\n");
    const startKeywords = ["si√™u th·ªã", "h√≥a ƒë∆°n", "c·ª≠a h√†ng", "mart", "coop"];
    let startIndex = lines.findIndex(
      (line) =>
        line.length < 50 &&
        startKeywords.some((k) => line.toLowerCase().includes(k))
    );
    if (startIndex === -1) {
      startIndex = lines.findIndex((line) =>
        /^[A-Z√Ä√Å·∫†·∫¢√É√Ç·∫¶·∫§·∫¨·∫®·∫™ƒÇ·∫∞·∫Æ·∫∂·∫≤·∫¥√à√â·∫∏·∫∫·∫º√ä·ªÄ·∫æ·ªÜ·ªÇ·ªÑ√å√ç·ªä·ªàƒ®√í√ì·ªå·ªé√ï√î·ªí·ªê·ªò·ªî·ªñ∆†·ªú·ªö·ª¢·ªû·ª†√ô√ö·ª§·ª¶≈®∆Ø·ª™·ª®·ª∞·ª¨·ªÆ·ª≤√ù·ª¥·ª∂·ª∏ƒê\s]{3,50}$/.test(
          line.trim()
        )
      );
    }
    if (startIndex === -1) startIndex = 0;

    const endKeywords = ["c·∫£m ∆°n", "thank you", "h·∫πn g·∫∑p l·∫°i", "qu√Ω kh√°ch"];
    let endIndex = -1;
    for (let i = lines.length - 1; i >= startIndex; i--) {
      if (endKeywords.some((k) => lines[i].toLowerCase().includes(k))) {
        endIndex = i;
        break;
      }
    }
    if (endIndex === -1) endIndex = lines.length - 1;

    return lines.slice(startIndex, endIndex + 1).join("\n");
  };

  // ‚úÖ PARSE AMOUNT (IMPROVED)
  const parseAmount = (amount: string): number => {
    if (!amount) return 0;

    let cleaned = amount.replace(/[ƒëd\s]/gi, "").trim();

    const dotCount = (cleaned.match(/\./g) || []).length;
    const commaCount = (cleaned.match(/,/g) || []).length;

    if (dotCount > 1) {
      cleaned = cleaned.replace(/\./g, "");
    } else if (commaCount > 1) {
      cleaned = cleaned.replace(/,/g, "");
    } else if (dotCount === 1 && commaCount === 0) {
      const parts = cleaned.split(".");
      if (parts[1] && parts[1].length === 3) {
        cleaned = cleaned.replace(".", "");
      }
    } else if (commaCount === 1 && dotCount === 0) {
      const parts = cleaned.split(",");
      if (parts[1] && parts[1].length === 3) {
        cleaned = cleaned.replace(",", "");
      } else {
        cleaned = cleaned.replace(",", ".");
      }
    } else if (dotCount === 1 && commaCount === 1) {
      cleaned = cleaned.replace(/\./g, "").replace(",", ".");
    }

    const num = parseFloat(cleaned);
    return isNaN(num) ? 0 : num;
  };

  // ‚úÖ EXTRACT FUNCTIONS
  const extractStore = (text: string): string => {
    const storePatterns = [
      /(?:c·ª≠a h√†ng|shop|store|si√™u th·ªã|mart|coop|mini|co\.?op)[:\s]*([^\n]{3,30})/i,
      /^([A-Z√Ä√Å·∫†·∫¢√É√Ç·∫¶·∫§·∫¨·∫®·∫™ƒÇ·∫∞·∫Æ·∫∂·∫≤·∫¥√à√â·∫∏·∫∫·∫º√ä·ªÄ·∫æ·ªÜ·ªÇ·ªÑ√å√ç·ªä·ªàƒ®√í√ì·ªå·ªé√ï√î·ªí·ªê·ªò·ªî·ªñ∆†·ªú·ªö·ª¢·ªû·ª†√ô√ö·ª§·ª¶≈®∆Ø·ª™·ª®·ª∞·ª¨·ªÆ·ª≤√ù·ª¥·ª∂·ª∏ƒê\s]{3,30})/m,
    ];

    for (const pattern of storePatterns) {
      const match = text.match(pattern);
      if (match) return match[1].trim();
    }

    const firstLine = text.split("\n")[0];
    if (
      firstLine &&
      firstLine.length > 3 &&
      /[A-Z√Ä√Å·∫†·∫¢√É√Ç·∫¶·∫§·∫¨·∫®·∫™]/.test(firstLine)
    ) {
      return firstLine.trim();
    }

    return "SI√äU TH·ªä";
  };

  const extractAddress = (text: string): string => {
    const match = text.match(/(?:ƒë·ªãa ch·ªâ|address|ƒëc)[:\s]*([^\n]{10,80})/i);
    return match ? match[1].trim() : "TP.HCM";
  };

  const extractPhone = (text: string): string => {
    const match = text.match(
      /(?:tel|phone|ƒëi·ªán tho·∫°i|ƒët|sƒët)[:\s]*([\d\s\-\.]{8,15})/i
    );
    return match ? match[1].replace(/\s/g, "") : "Kh√¥ng c√≥";
  };

  const extractDate = (text: string): string => {
    const patterns = [
      /(?:ng√†y|date)[:\s]*(\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4})/i,
      /(\d{1,2}[-\/]\d{1,2}[-\/]\d{2,4})/,
      /(\d{2,4}[-\/]\d{1,2}[-\/]\d{1,2})/,
    ];
    for (const p of patterns) {
      const m = text.match(p);
      if (m) return m[1];
    }
    return new Date().toLocaleDateString("vi-VN");
  };

  const extractTime = (text: string): string => {
    const match = text.match(/(\d{1,2}:\d{2}(?::\d{2})?)/);
    return match
      ? match[1]
      : new Date().toLocaleTimeString("vi-VN", {
          hour: "2-digit",
          minute: "2-digit",
        });
  };

  const extractTotal = (text: string): number => {
    const lines = text.split("\n");
    const keywords = ["th√†nh ti·ªÅn", "thanh to√°n", "payment"];
    const priceRegex = /^([\d,.]+(ƒë|d)?)$/;

    const regex = /(?:th√†nh ti·ªÅn|thanh to√°n|payment)[:\s]*([0-9,.ƒë]+)/i;
    const match = text.match(regex);
    if (match) {
      const num = parseAmount(match[1]);
      if (num > 0) return num;
    }

    for (let i = 0; i < lines.length; i++) {
      const lineLower = lines[i].toLowerCase();
      if (keywords.some((k) => lineLower.includes(k))) {
        for (let j = 1; j <= 3 && i + j < lines.length; j++) {
          if (priceRegex.test(lines[i + j])) {
            const num = parseAmount(lines[i + j]);
            if (num > 0) return num;
          }
        }
      }
    }

    const subtotalKeywords = ["t·ªïng", "total", "sum", "c·ªông"];
    for (let i = 0; i < lines.length; i++) {
      const lineLower = lines[i].toLowerCase();
      if (subtotalKeywords.some((k) => lineLower.includes(k))) {
        for (let j = 1; j <= 3 && i + j < lines.length; j++) {
          if (priceRegex.test(lines[i + j])) {
            const num = parseAmount(lines[i + j]);
            if (num > 0) return num;
          }
        }
      }
    }
    return 0;
  };

  const extractTax = (text: string): number => {
    const lines = text.split("\n");
    const keywords = ["vat", "thu·∫ø", "tax"];
    const priceRegex = /^([\d,.]+(ƒë|d)?)$/;

    const regex = /(?:vat|thu·∫ø|tax)\s*\(?\d*%?\)?[:\s]*([0-9,.ƒë]+)/i;
    const match = text.match(regex);
    if (match) {
      return parseAmount(match[1]);
    }

    for (let i = 0; i < lines.length; i++) {
      const lineLower = lines[i].toLowerCase();
      if (keywords.some((k) => lineLower.includes(k))) {
        for (let j = 1; j <= 3 && i + j < lines.length; j++) {
          if (priceRegex.test(lines[i + j])) {
            return parseAmount(lines[i + j]);
          }
        }
      }
    }
    return 0;
  };

  const extractItemsAdvanced = (text: string): ExpenseItem[] => {
    const items: ExpenseItem[] = [];
    const lines = text
      .split("\n")
      .map((l) => l.trim())
      .filter((l) => l.length > 0);

    const summaryKeywords = [
      "t·ªïng",
      "vat",
      "thu·∫ø",
      "th√†nh ti·ªÅn",
      "thanh to√°n",
      "c·ªông",
      "total",
      "sum",
      "payment",
    ];
    const priceRegex = /^([\d,.]+)$/;
    const nameRegex =
      /^[a-z√†√°·∫°·∫£√£√¢·∫ß·∫•·∫≠·∫©·∫´ƒÉ·∫±·∫Ø·∫∑·∫≥·∫µ√®√©·∫π·∫ª·∫Ω√™·ªÅ·∫ø·ªá·ªÉ·ªÖ√¨√≠·ªã·ªâƒ©√≤√≥·ªç·ªè√µ√¥·ªì·ªë·ªô·ªï·ªó∆°·ªù·ªõ·ª£·ªü·ª°√π√∫·ª•·ªß≈©∆∞·ª´·ª©·ª±·ª≠·ªØ·ª≥√Ω·ªµ·ª∑·ªπƒë\s\-\/]{3,50}$/i;

    const itemNames: string[] = [];
    const itemPrices: number[] = [];

    for (const line of lines) {
      if (summaryKeywords.some((k) => line.toLowerCase().startsWith(k))) {
        break;
      }
      if (nameRegex.test(line) && !line.toLowerCase().includes("h√≥a ƒë∆°n")) {
        itemNames.push(line);
      }
    }

    for (const line of lines) {
      if (priceRegex.test(line)) {
        const amount = parseAmount(line);
        if (amount >= 1000) {
          itemPrices.push(amount);
        }
      }
    }

    const count = Math.min(itemNames.length, itemPrices.length);
    for (let i = 0; i < count; i++) {
      items.push({
        name: itemNames[i],
        quantity: 1,
        amount: itemPrices[i],
      });
    }
    return items;
  };

  const extractDiscount = (text: string): number => {
    const match = text.match(/(?:gi·∫£m gi√°|discount|km)[:\s]*([0-9,.ƒë]+)/i);
    if (match) {
      return parseAmount(match[1]);
    }
    return 0;
  };

  const parseReceipt = (text: string): ExpenseData => {
    const originalRawText = text;
    const cleanedText = cleanReceipt(text);

    const items = extractItemsAdvanced(cleanedText);
    const total = extractTotal(cleanedText);
    const tax = extractTax(cleanedText);
    const discount = extractDiscount(cleanedText);

    let calculatedTotal = 0;
    if (items.length > 0) {
      calculatedTotal = items.reduce((s, i) => s + i.amount, 0);
    }

    let finalTotal = total;

    if (finalTotal === 0) {
      if (calculatedTotal > 0 && tax > 0 && calculatedTotal > tax) {
        finalTotal = calculatedTotal + tax - discount;
      } else {
        finalTotal = calculatedTotal - discount;
      }
    }

    return {
      store: extractStore(cleanedText),
      address: extractAddress(cleanedText),
      phone: extractPhone(cleanedText),
      date: extractDate(cleanedText),
      time: extractTime(cleanedText),
      total: finalTotal > 0 ? finalTotal : calculatedTotal - discount,
      tax,
      discount: discount,
      items:
        items.length > 0
          ? items
          : [{ name: "Mua s·∫Øm", quantity: 1, amount: finalTotal || 0 }],
      method: "Ti·ªÅn m·∫∑t",
      createdAt: new Date().toISOString(),
      rawText: originalRawText,
    };
  };

  // ‚úÖ TAKE PHOTO
  const takePhoto = async () => {
    setLoading(true);
    try {
      if (!cameraRef.current) throw new Error("Camera ch∆∞a s·∫µn s√†ng.");

      const photo = await cameraRef.current.takePictureAsync({
        quality: 0.8,
        exif: false,
      });
      if (!photo?.uri) throw new Error("Kh√¥ng th·ªÉ l∆∞u ·∫£nh.");

      setPhoto(photo.uri);

      const compressed = await ImageManipulator.manipulateAsync(
        photo.uri,
        [{ resize: { width: 1600 } }],
        { compress: 0.8, format: ImageManipulator.SaveFormat.JPEG }
      );

      const ocrText = await performOCR(compressed.uri);
      const data = parseReceipt(ocrText);

      setExpensesData(data);
      setStep("result");
    } catch (error: any) {
      Alert.alert("L·ªói", error.message || "Kh√¥ng th·ªÉ x·ª≠ l√Ω ·∫£nh.");
    } finally {
      setLoading(false);
    }
  };

  // ‚úÖ UPLOAD IMAGE
  const uploadImage = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        quality: 0.8,
        allowsEditing: false,
      });

      if (result.canceled || !result.assets?.[0]?.uri) return;

      const imageUri = result.assets[0].uri;
      setPhoto(imageUri);
      setLoading(true);

      const compressed = await ImageManipulator.manipulateAsync(
        imageUri,
        [{ resize: { width: 1600 } }],
        { compress: 0.8, format: ImageManipulator.SaveFormat.JPEG }
      );

      const ocrText = await performOCR(compressed.uri);
      const data = parseReceipt(ocrText);

      setExpensesData(data);
      setStep("result");
    } catch (error: any) {
      Alert.alert("L·ªói", error.message || "Kh√¥ng th·ªÉ x·ª≠ l√Ω ·∫£nh.");
    } finally {
      setLoading(false);
    }
  };

  // ‚úÖ SAVE TO SQLITE (OFFLINE-FIRST)
  const saveExpenseToSQLite = async (data: ExpenseData) => {
    try {
      const user = auth.currentUser;
      if (!user) throw new Error("B·∫°n ch∆∞a ƒëƒÉng nh·∫≠p");

      // L∆∞u v√†o SQLite v·ªõi synced = false
      const localId = await database.addExpense({
        userId: user.uid,
        store: data.store,
        address: data.address,
        phone: data.phone,
        date: data.date,
        time: data.time,
        total: data.total,
        tax: data.tax,
        discount: data.discount,
        items: JSON.stringify(data.items), // Convert to JSON string
        method: data.method,
        createdAt: data.createdAt,
        rawText: data.rawText,
        synced: 0,
        syncAttempts: 0,
      });

      console.log(`‚úÖ Expense saved to SQLite with ID: ${localId}`);

      // Trigger immediate sync n·∫øu c√≥ m·∫°ng
      if (isOnline) {
        console.log("üåê Triggering immediate sync to Firebase...");
        syncService.syncToFirebase().then(() => {
          updateSyncStatus();
        });
      } else {
        console.log("üìµ Offline - will sync when online");
        updateSyncStatus();
      }

      return true;
    } catch (error: any) {
      console.error("‚ùå Error saving to SQLite:", error);
      throw error;
    }
  };

  // ‚úÖ HANDLE SAVE EXPENSE
  const handleSaveExpense = async () => {
    if (!expensesData) return;

    try {
      await saveExpenseToSQLite(expensesData);

      const message = isOnline
        ? "ƒê√£ l∆∞u v√†o v√≠ v√† ƒë·ªìng b·ªô l√™n cloud!"
        : "ƒê√£ l∆∞u v√†o v√≠! S·∫Ω t·ª± ƒë·ªông ƒë·ªìng b·ªô khi c√≥ m·∫°ng.";

      Alert.alert("Th√†nh c√¥ng", message, [
        {
          text: "OK",
          onPress: () => navigation.goBack(),
        },
      ]);
    } catch (error: any) {
      Alert.alert(
        "L·ªói",
        error.message || "Kh√¥ng th·ªÉ l∆∞u d·ªØ li·ªáu. Vui l√≤ng th·ª≠ l·∫°i.",
        [{ text: "OK" }]
      );
    }
  };

  // ‚úÖ RETRY & DELETE
  const handleRetry = () => {
    setPhoto(null);
    setExpensesData(null);
    setEditMode(false);
    setStep("camera");
  };

  const deleteItem = (index: number) => {
    if (!expensesData) return;
    const newItems = expensesData.items.filter((_, i) => i !== index);
    const newTotal = newItems.reduce((s, i) => s + i.amount, 0);
    setExpensesData({ ...expensesData, items: newItems, total: newTotal });
  };

  // ‚úÖ SYNC STATUS BADGE
  const SyncStatusBadge = () => {
    if (unsyncedCount === 0) return null;

    return (
      <View style={styles.syncBadge}>
        <Icon
          name={isOnline ? "cloud-sync" : "cloud-off-outline"}
          size={16}
          color="#fff"
        />
        <Text style={styles.syncBadgeText}>
          {isOnline
            ? `ƒêang sync ${unsyncedCount}...`
            : `${unsyncedCount} ch∆∞a sync`}
        </Text>
      </View>
    );
  };

  // ‚úÖ CAMERA VIEW
  if (step === "camera") {
    return (
      <View style={styles.container}>
        <CameraView ref={cameraRef} style={styles.fullCamera} facing="back" />

        <View style={styles.fullScanOverlay} pointerEvents="none">
          <View style={styles.largeScanFrame} />
          <Text style={styles.largeOverlayText}>
            ƒê·∫∑t h√≥a ƒë∆°n v√†o khung h√¨nh
          </Text>
          <View style={styles.arrowContainer}>
            <Text style={styles.arrowText}>‚Üì</Text>
            <Text style={styles.arrowText}>‚Üì</Text>
          </View>
        </View>

        <View style={styles.fullButtonSection}>
          <View style={styles.header}>
            <TouchableOpacity onPress={() => navigation.goBack()}>
              <Icon name="arrow-left" size={24} color="#212121" />
            </TouchableOpacity>
            <Text style={styles.headerTitle}>Qu√©t h√≥a ƒë∆°n</Text>
            <SyncStatusBadge />
          </View>

          <View style={styles.buttonContainer}>
            <TouchableOpacity
              style={[
                styles.largeStartButton,
                loading && styles.startButtonDisabled,
              ]}
              onPress={takePhoto}
              disabled={loading}
            >
              {loading ? (
                <>
                  <ActivityIndicator size="small" color="#fff" />
                  <Text style={styles.largeButtonText}>ƒêANG X·ª¨ L√ù...</Text>
                </>
              ) : (
                <>
                  <Icon name="camera" size={28} color="#fff" />
                  <Text style={styles.largeButtonText}>CH·ª§P NGAY</Text>
                </>
              )}
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.uploadButton}
              onPress={uploadImage}
              disabled={loading}
            >
              <Icon name="image" size={28} color="#fff" />
              <Text style={styles.largeButtonText}>T·∫¢I ·∫¢NH L√äN</Text>
            </TouchableOpacity>

            <View style={styles.tipContainer}>
              <Icon name="information" size={16} color="#666" />
              <Text style={styles.tipText}>
                {isOnline
                  ? "ƒê·∫£m b·∫£o h√≥a ƒë∆°n r√µ r√†ng v√† ƒë·ªß s√°ng"
                  : "‚ö†Ô∏è Ch·∫ø ƒë·ªô offline - d·ªØ li·ªáu s·∫Ω sync khi c√≥ m·∫°ng"}
              </Text>
            </View>
          </View>
        </View>
      </View>
    );
  }

  // ‚úÖ RESULT VIEW
  if (step === "result" && expensesData) {
    return (
      <View style={styles.container}>
        {photo && <Image source={{ uri: photo }} style={styles.resultImage} />}

        <ScrollView style={styles.resultSection}>
          <View style={styles.storeCard}>
            <View style={styles.storeRow}>
              <Icon name="store" size={20} color="#1976D2" />
              <Text style={styles.storeName}>{expensesData.store}</Text>
            </View>
            <View style={styles.storeRow}>
              <Icon name="map-marker" size={16} color="#666" />
              <Text style={styles.storeAddress}>{expensesData.address}</Text>
            </View>
          </View>

          <View style={styles.expenseCard}>
            <Text style={styles.cardTitle}>
              {expensesData.date} - {expensesData.time}
            </Text>
            <Text style={styles.cardTotal}>
              {expensesData.total.toLocaleString()} VNƒê
            </Text>
            {expensesData.tax > 0 && (
              <Text style={styles.cardSubtext}>
                (Bao g·ªìm VAT: {expensesData.tax.toLocaleString()}ƒë)
              </Text>
            )}
          </View>

          {expensesData.items.map((item, index) => (
            <View key={index} style={styles.itemCard}>
              <View style={styles.itemLeft}>
                <Text style={styles.itemName}>‚Ä¢ {item.name}</Text>
                <Text style={styles.itemQty}>(x{item.quantity})</Text>
              </View>
              <Text style={styles.itemPrice}>
                {item.amount.toLocaleString()} VNƒê
              </Text>
              {editMode && (
                <TouchableOpacity
                  style={styles.deleteBtn}
                  onPress={() => deleteItem(index)}
                >
                  <Icon name="trash-can-outline" size={16} color="#f44336" />
                </TouchableOpacity>
              )}
            </View>
          ))}
        </ScrollView>

        <View style={styles.actionButtons}>
          {!editMode ? (
            <TouchableOpacity
              style={styles.editButton}
              onPress={() => setEditMode(true)}
            >
              <Text style={styles.editButtonText}>CH·ªàNH S·ª¨A</Text>
            </TouchableOpacity>
          ) : (
            <TouchableOpacity
              style={styles.saveButton}
              onPress={handleSaveExpense}
            >
              <Icon
                name={isOnline ? "content-save" : "content-save-off"}
                size={20}
                color="#fff"
              />
              <Text style={styles.saveButtonText}>
                {isOnline ? "L∆ØU V√ÄO V√ç" : "L∆ØU (OFFLINE)"}
              </Text>
            </TouchableOpacity>
          )}
          <TouchableOpacity style={styles.retryButton} onPress={handleRetry}>
            <Text style={styles.retryButtonText}>CH·ª§P L·∫†I</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  return null;
};
// ‚úÖ STYLES
const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#000" },
  centerContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#fff",
    padding: 20,
  },
  loadingText: { marginTop: 10, fontSize: 16, color: "#666" },
  errorTitle: {
    fontSize: 20,
    fontWeight: "600",
    color: "#f44336",
    marginTop: 20,
  },
  errorText: {
    fontSize: 14,
    color: "#666",
    textAlign: "center",
    marginTop: 10,
  },
  grantButton: {
    backgroundColor: "#2196F3",
    paddingHorizontal: 30,
    paddingVertical: 15,
    borderRadius: 8,
    marginTop: 20,
  },
  grantButtonText: { color: "#fff", fontSize: 16, fontWeight: "600" },
  backButton: { paddingHorizontal: 30, paddingVertical: 15, marginTop: 10 },
  backButtonText: { color: "#2196F3", fontSize: 16 },
  fullCamera: { flex: 1 },
  fullScanOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "rgba(0,0,0,0.4)",
  },
  largeScanFrame: {
    width: "85%",
    height: "50%",
    borderWidth: 3,
    borderColor: "#00FF00",
    backgroundColor: "rgba(0,255,0,0.1)",
    borderRadius: 16,
  },
  largeOverlayText: {
    color: "#fff",
    fontSize: 20,
    fontWeight: "700",
    marginTop: 20,
    textAlign: "center",
  },
  arrowContainer: { marginTop: 15, alignItems: "center" },
  arrowText: { color: "#fff", fontSize: 14, marginVertical: 2 },
  fullButtonSection: {
    position: "absolute",
    bottom: 0,
    left: 0,
    right: 0,
    backgroundColor: "#fff",
    paddingBottom: 40,
  },
  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingHorizontal: 20,
    paddingVertical: 15,
  },
  headerTitle: { fontSize: 20, fontWeight: "600", color: "#212121", flex: 1 },
  syncBadge: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#FF9800",
    paddingHorizontal: 10,
    paddingVertical: 5,
    borderRadius: 12,
    gap: 5,
  },
  syncBadgeText: { color: "#fff", fontSize: 11, fontWeight: "600" },
  buttonContainer: { paddingHorizontal: 20 },
  largeStartButton: {
    backgroundColor: "#2196F3",
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
    paddingVertical: 18,
    paddingHorizontal: 30,
    borderRadius: 16,
    marginHorizontal: 20,
    marginBottom: 12,
    gap: 12,
  },
  uploadButton: {
    backgroundColor: "#4CAF50",
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
    paddingVertical: 18,
    paddingHorizontal: 30,
    borderRadius: 16,
    marginHorizontal: 20,
    marginBottom: 20,
    gap: 12,
  },
  startButtonDisabled: { opacity: 0.6 },
  largeButtonText: { color: "#fff", fontSize: 18, fontWeight: "700" },
  tipContainer: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    paddingHorizontal: 20,
    paddingVertical: 10,
  },
  tipText: { color: "#666", fontSize: 12, marginLeft: 5 },
  resultImage: { flex: 0.35, width: "100%" },
  resultSection: { flex: 0.65, backgroundColor: "#fff" },
  storeCard: {
    backgroundColor: "#E8F5E8",
    padding: 15,
    borderRadius: 12,
    margin: 15,
  },
  storeRow: { flexDirection: "row", alignItems: "center", marginVertical: 3 },
  storeName: {
    fontSize: 16,
    fontWeight: "600",
    color: "#2E7D32",
    marginLeft: 8,
  },
  storeAddress: { fontSize: 12, color: "#666", marginLeft: 8 },
  expenseCard: {
    backgroundColor: "#E3F2FD",
    padding: 15,
    borderRadius: 12,
    margin: 15,
  },
  cardTitle: { fontSize: 14, color: "#1976D2", marginBottom: 5 },
  cardTotal: { fontSize: 22, fontWeight: "bold", color: "#D32F2F" },
  cardSubtext: { fontSize: 12, color: "#666", marginTop: 5 },
  itemCard: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    padding: 12,
    backgroundColor: "#F5F5F5",
    borderRadius: 8,
    marginHorizontal: 15,
    marginBottom: 8,
  },
  itemLeft: { flex: 1 },
  itemName: { fontSize: 14, color: "#212121" },
  itemQty: { fontSize: 12, color: "#666" },
  itemPrice: { fontWeight: "600", color: "#1976D2", marginLeft: 10 },
  deleteBtn: { padding: 4 },
  actionButtons: {
    flexDirection: "row",
    padding: 15,
    backgroundColor: "#fff",
    borderTopWidth: 1,
    borderTopColor: "#EEE",
  },
  editButton: {
    flex: 1,
    backgroundColor: "#FF9800",
    padding: 15,
    borderRadius: 8,
    alignItems: "center",
    marginRight: 10,
  },
  saveButton: {
    flex: 1,
    backgroundColor: "#4CAF50",
    padding: 15,
    borderRadius: 8,
    alignItems: "center",
    marginRight: 10,
    flexDirection: "row",
    justifyContent: "center",
    gap: 8,
  },
  editButtonText: { color: "#fff", fontSize: 16, fontWeight: "600" },
  saveButtonText: { color: "#fff", fontSize: 16, fontWeight: "600" },
  retryButton: {
    paddingHorizontal: 15,
    paddingVertical: 15,
    alignItems: "center",
  },
  retryButtonText: { color: "#2196F3", fontSize: 14, fontWeight: "500" },
});

export default Quethoadon;
